Got it ‚Äî you basically want ONE brain, ONE behavior for the bot, no matter where it shows up:
	‚Ä¢	admin preview
	‚Ä¢	demo page (FloatingChatWidget)
	‚Ä¢	public widget.js embed
	‚Ä¢	client site

Here‚Äôs a single prompt you can paste into Replit to unify everything and make sure all chat surfaces use the same logic + features (booking, lead capture, needs-review, etc.).

‚∏ª

üîß REPLIT PROMPT ‚Äî UNIFY ALL CHAT WIDGETS (DEMO, CLIENT, ADMIN, PUBLIC)

You are working on the Treasure Coast AI platform.

Goal:
Make sure the exact same chatbot behavior and capabilities are available everywhere:
	‚Ä¢	Super-admin/admin ‚Äútest bot‚Äù / preview in the dashboard
	‚Ä¢	Demo pages (e.g. demo-bot.tsx using FloatingChatWidget)
	‚Ä¢	Public embeddable widget (widget.js + <script> snippet)
	‚Ä¢	Any other internal test widget pages

All of these must use one shared implementation so features are never out of sync.

Key features that must work identically everywhere:
	‚Ä¢	AI conversation backend
	‚Ä¢	lead capture (name, contact, intent, etc.)
	‚Ä¢	booking intent detection + redirect to external booking URL
	‚Ä¢	logging of conversations & leads
	‚Ä¢	‚ÄúNeeds Review‚Äù flagging
	‚Ä¢	analytics tracking (message counts, booking clicks, etc.)

Do NOT create separate logic per widget. Unify them.

‚∏ª

1. Create a Single Shared Chat Client Layer

Refactor the frontend so that all chat surfaces use the same underlying module.

Create something like:

// client/src/lib/chatClient.ts (or similar)
export function createChatClient(config: {
  clientId: string;
  botId: string;
  widgetToken?: string;
  source: "admin_preview" | "public_widget" | "demo_page" | "client_site";
}) {
  // Handles:
  // - sending messages to chat API
  // - handling streaming or responses
  // - lead capture events
  // - booking events
  // - analytics tracking
}

And a shared React hook:

// client/src/hooks/useChatAssistant.ts
export function useChatAssistant(config) {
  // Wrap createChatClient + local UI state
}

All UI components (FloatingChatWidget, admin preview chat, widget.js wrapper) should call this shared hook/client instead of each rolling their own logic.

‚∏ª

2. Wire All Widgets to the Shared Logic

Update the following (names may differ, adapt to your actual structure):
	‚Ä¢	client/src/pages/demo-bot.tsx (FloatingChatWidget)
	‚Ä¢	Any admin preview page/component (e.g. Bot Preview in Control Center)
	‚Ä¢	The public embed script handler (public/widget.js or similar)
	‚Ä¢	Any standalone widget test page (widget-test.html + associated JS)

Each of these should:
	1.	Pass the correct clientId / workspaceId and botId.
	2.	Pass source (e.g. "demo_page" or "public_widget").
	3.	Use the same useChatAssistant hook to:
	‚Ä¢	send messages
	‚Ä¢	receive responses
	‚Ä¢	trigger lead/booking events

Remove duplicated chat-request logic from any of these components and centralize it into the shared module.

‚∏ª

3. Ensure Booking & Lead Capture Works Everywhere

Wherever the bot is used (demo, admin, public, client site), the following must happen:
	‚Ä¢	When the AI decides to capture a lead or detect booking intent, the server-side logic should fire:
	‚Ä¢	create/update a lead record
	‚Ä¢	mark bookingIntent = true if applicable
	‚Ä¢	track link clicks & events

The frontend widget (no matter which one) should:
	‚Ä¢	Render booking links as buttons/links using the same UI logic.
	‚Ä¢	Use the same event tracking function for clicks (e.g. trackBookingClick(leadId)).

If there is any widget that currently skips lead capture or booking events, update it to call the shared client layer.

‚∏ª

4. Respect Security Everywhere

For the public widget:
	‚Ä¢	continue enforcing:
	‚Ä¢	widgetToken validation
	‚Ä¢	allowedDomains check
	‚Ä¢	config (clientId, botId, widgetToken) should be passed into the shared chat client.

For admin/demo widgets:
	‚Ä¢	they may bypass widgetToken & domain checks (since they are internal), but they must still:
	‚Ä¢	call the same chat endpoint
	‚Ä¢	tag source = "admin_preview" or "demo_page" so analytics can distinguish them from real traffic.

Do not duplicate security logic ‚Äî keep it server-side and shared.

‚∏ª

5. Testing: Prove All 3+ Surfaces Behave the Same

After refactoring to a shared chat client, run an end-to-end manual test in 3 places:
	1.	Admin preview / test chat
	2.	Demo page (FloatingChatWidget)
	3.	Public widget test page (widget.js embed)

In each:
	‚Ä¢	Ask general questions (hours, services) ‚Üí verify consistent answers.
	‚Ä¢	Trigger lead capture (‚ÄúCan someone contact me about X?‚Äù) ‚Üí verify leads appear identically in dashboards.
	‚Ä¢	Trigger booking (‚ÄúI want to book an appointment‚Ä¶‚Äù) ‚Üí verify:
	‚Ä¢	same booking flow
	‚Ä¢	same external booking URL
	‚Ä¢	same style of response
	‚Ä¢	booking leads + clicks are recorded.

If any behavior differs between surfaces, fix it in the shared chat client/hook, not locally.

‚∏ª

6. Avoid Future Drift

Add a small developer note / comment block in the shared module explaining:

‚ÄúAll chat widgets (admin preview, demo pages, public widget.js, client sites) MUST use this shared chat client. Do not reimplement chat logic directly in components; wire them into this module instead. This keeps booking, lead capture, and analytics behavior consistent across the platform.‚Äù

This is critical to prevent the issue you just saw (FloatingChatWidget behaving differently from the public widget).

‚∏ª

7. Deliverable

When done, you should be able to say:
	‚Ä¢	‚ÄúNo matter where the chatbot appears ‚Äî demo, admin preview, client site embed ‚Äî it uses the same backend, same booking logic, same lead capture, and same analytics. All I change is clientId, botId, and config; behavior is identical.‚Äù

Please implement this refactor and then run a short QA summary describing:
	‚Ä¢	Which components now use the shared client
	‚Ä¢	How you verified all chat surfaces behave identically
	‚Ä¢	Any remaining edge cases.

‚∏ª

That tells Replit exactly what you want:

One unified chatbot brain ‚Äî full capacity, everywhere.